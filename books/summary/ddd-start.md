# DDD Start!

> 최범균, 지앤선, 2016 [[상세정보]](http://book.naver.com/bookdb/book_detail.nhn?bid=10615650)



## 1. 도메인 모델 시작

> 도메인 = 구현해야 할 소프트웨어 대상, 해결하고자 하는 문제 영역

한 도메인은 다시 하위 도메인으로 나눌 수 있음. 예를 들어 '온라인 서점' 이라는 도메인 하위에는 주문, 회원, 리뷰, 결제, 배송 등... 하위 도메인을 어떻게 구성할지 여부는 상황에 따라 다름. 



### 도메인모델

> 특정 도메인을 개념적으로 표현한 것

도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델.

- 도메인 모델은 객체로만 모델링할 수 있는 것은 아님.
- 도메인을 이해하는데 도움이 된다면 표현 방식이 무엇인지는 중요하지 않음.
- 도메인은 다수의 하위 도메인으로 구성되는데, 하위 도메인마다 별도의 모델을 가짐.



### 도메인모델 도출

도메인을 모델링할 때 기본이 되는 작업은

- 핵심 구성요소
- 규칙
- 기능

모델을 구성하는 위 요소들을 찾는 것. 이 과정은 요구사항에서 출발함.



### 엔티티와 벨류

도출한 모델은 크게 엔티티와 벨류로 구분.



#### 엔티티
엔티티의 가장 큰 특징은 식별자를 가짐. 엔티티 식별자를 생성하는 방식은 도메인이나 회사에 따라 다를 수 있음. 흔히 다음 중 한가지 방식으로 생성함.

- 특정 규칙에 따라 생성
- UUID 사용
- 값을 직접 입력
- 일련번호 사용(시퀀스나 DB의 자동 증가 컬럼 사용)



#### 벨류 타입

벨류 타입은 개념적으로 완전한 하나를 표현.
벨류 타입을 사용하면 벨류 타입을 위한 기능을 클래스 안에 캡슐화할 수 있음.

```java
private int calculateAmounts(int price, int quantity) {
    return price * queantity;
}

// 위와 같은 로직이 아래와 같이 변경될 수 있음.

private int calculateAmounts(Money price, int quantity) {
    return price.multiply(quantity);
}
```
- 벨류 타입은 불변으로 다룬다.
- 두 벨류 객체를 비교할 때는 모든 속성이 같은지 비교한다.



## 2. 아키텍쳐 개요

> 전형적인 네 개의 영역: 표현 - 응용 - 도메인 - 인프라스트럭처

네 영역을 구성할 때는 일반적으로 계층 구조를 적용. 계층 구조를 엄격하게 적용하면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 함. 

![전형적인 계층 구조상 의존관계](https://user-images.githubusercontent.com/13076271/39467162-847e2a8e-4d67-11e8-8edb-6add012307d7.png)

예를 들어, 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라스트럭처 계층에 의존하기도 함. 하지만, 인프라스트럭처에 의존할 때는 두 가지 문제가 생김.

- 테스트의 어려움
- 기능 확장의 어려움



### DIP

이런 문제를 해소하기 위해서는 DIP<sup>dependency inversion principle</sup>를 적용해야 함.
추상화한 인터페이스를 도입함으로써 저수준 모듈이 고수준 모듈에 의존하도록 변경함.

![DIP를 적용한 구조](https://user-images.githubusercontent.com/13076271/39467265-2ecb8d9c-4d68-11e8-9e48-88dc1c78e67a.png)

주의할 점은 **저수준 모듈 관점에서 인터페이스를 도출**하면 DIP를 잘못 적용하게 됨. 고수준 모듈의 관점에서 추상화한 인터페이스를 도출하고 고수준 모듈에 위치해야 함.

![잘못된 DIP 적용 예](https://user-images.githubusercontent.com/13076271/39467340-825a6b72-4d68-11e8-9542-325db1c2072e.png)



### 도메인 영역의 주요 구성요소

- 엔티티: 고유의 식별자를 갖는 객체로 자신의 라이프사이클을 가짐. 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체.
- 벨류: 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나의 도메인 객체의 속성을 표현할 때 사용.
- 애그리거트: 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것.
- 리포지터리: 도메인 모델의 영속성 처리.
- 도메인 서비스: 특정 엔티티에 속하지 않은 도메인 로직 제공.



## 3. 애그리거트
> 애그리거트: 관련된 객체를 하나의 군으로 묶은 것.
복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요.

- 애그리거트 경계를 설정할 때 기본이 되는 것인 도메인 규칙과 요구사항

TODO: WIP



## 6. 응용 서비스와 표현 영역

### 응용서비스

응용서비스의 역할
- 클라이언트가 요청한 기능을 실행

- 요청을 처리하기 위해 레파지토리로부터 도메인 객체를 구하고 도메인 객체 간의 실행 흐름을 제어

- 주된 역할 중 하나는 트랜잭션 처리

- 일종의 [파사드(facade)](https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%82%AC%EB%93%9C_%ED%8C%A8%ED%84%B4) 역할

  

일반적으로 도메인 로직이 응용 서비스에 구현 되는 경우가 많은데 이 때 문제는,
- 코드의 응집성이 떨어짐
- 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아짐. 코드의 중복



또한, 표현 영역에 해당하는 `HttpServletRequest`나 `HttpSession`과 같은 웹 서비스 표현 영역에 해당하는 타입을 응용 서비스에 전달하면 안됨.



#### 응용 서비스의 크기
- 한 응용 서비스 클래스에 한 도메인의 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현

한 응용 서비스에 모든 기능을 모두 구현하면 동일한 로직을 위한 코드 중복을 제거하는 것이 쉽지만 클래스의 크기가 커짐.



#### 응용 서비스에 인터페이스를 구현해야 할까?
인터페이스가 필요한 몇가지 상황 중 하나는 구현 클래스가 여러개인 경우임. 하지만 응용 서비스의 경우 다형성이 필요한 경우가 거의 없음.
다음 글도 참고할만 함: [우아한형제들 기술 블로그 - 손권남님, 안정된 의존관계 원칙과 안정된 추상화 원칙에 대하여](http://woowabros.github.io/study/2018/03/05/sdp-sap.html)



### 표현영역

표현 영역의 역할
- 사용자가 시스템을 사용할 수 있는 (화면)흐름을 제공하고 제어
- 사용자 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
- 사용자 세션을 관리



> 읽으면서 느낀 점: 우리의 응용 서비스는 너무 많은 책임을 지고 있고 방대함. 계층 구조는 책의 예시와 비슷한 구조를 가지지만 도메인이 가져야 할 책임이 응용 서비스에 있는 경우가 많고 예외가 발생했을 때 어떤 HTTP 응답을 해야 할지도 서비스가 알고 있음. 서비스가 이 것 까지 알아야 할까?



## 7. 도메인 서비스
- 애그리거트에 넣기 애매한 도메인 개념을 구현
- 도메인 서비스는 도메인 로직을 수행하지 응용 로직을 수행하지 않음
- 상태 없이 로직만 구현함
- 응용 서비스가 애그리거트 객체에 도메인 서비스를 전달하는 책임



특정 기능이 응용서비스인지 도메인서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 게산하는지 검사해봄. 두 개 이상의 애거리거트의 도메인 로직을 수행해야 한다면 도메인 서비스로 구현.



> 읽으면서 느낀점: 도메인 서비스라는 개념을 이제까지는 따로 사용해 본 적이 없는 것 같음. 물론 도메인 개념을 나타내기 위해 별도의 클래스를 도출하는 경우는 있지만 도메인 서비스라고 의식하지는 않았음. 그리고 도메인 로직이 응용 서비스에 포함되는 경우가 많았음. 책에서 말한대로 응용 서비스와 도메인 서비스를 나눠 관리한다면 코드의 응집도가 더 높아져 관리하기 좀 더 편할 것 같음. 특히 응용서비스가 애그리거트에 도메인 서비스를 전달하고, 애그리거트 내부에서 도메인 로직을 처리하는게 인상 깊음.
