# DDD Start!

> 최범균, 지앤선, 2016 [[상세정보]](http://book.naver.com/bookdb/book_detail.nhn?bid=10615650)



## 1. 도메인 모델 시작

> 도메인 = 구현해야 할 소프트웨어 대상, 해결하고자 하는 문제 영역

한 도메인은 다시 하위 도메인으로 나눌 수 있음. 예를 들어 '온라인 서점' 이라는 도메인 하위에는 주문, 회원, 리뷰, 결제, 배송 등... 하위 도메인을 어떻게 구성할지 여부는 상황에 따라 다름. 



### 도메인모델

> 특정 도메인을 개념적으로 표현한 것

도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델.

- 도메인 모델은 객체로만 모델링할 수 있는 것은 아님.
- 도메인을 이해하는데 도움이 된다면 표현 방식이 무엇인지는 중요하지 않음.
- 도메인은 다수의 하위 도메인으로 구성되는데, 하위 도메인마다 별도의 모델을 가짐.



### 도메인모델 도출

도메인을 모델링할 때 기본이 되는 작업은

- 핵심 구성요소
- 규칙
- 기능

모델을 구성하는 위 요소들을 찾는 것. 이 과정은 요구사항에서 출발함.



### 엔티티와 벨류

도출한 모델은 크게 엔티티와 벨류로 구분.



#### 엔티티
엔티티의 가장 큰 특징은 식별자를 가짐. 엔티티 식별자를 생성하는 방식은 도메인이나 회사에 따라 다를 수 있음. 흔히 다음 중 한가지 방식으로 생성함.

- 특정 규칙에 따라 생성
- UUID 사용
- 값을 직접 입력
- 일련번호 사용(시퀀스나 DB의 자동 증가 컬럼 사용)



#### 벨류 타입

벨류 타입은 개념적으로 완전한 하나를 표현.
벨류 타입을 사용하면 벨류 타입을 위한 기능을 클래스 안에 캡슐화할 수 있음.

```java
private int calculateAmounts(int price, int quantity) {
    return price * queantity;
}

// 위와 같은 로직이 아래와 같이 변경될 수 있음.

private int calculateAmounts(Money price, int quantity) {
    return price.multiply(quantity);
}
```
- 벨류 타입은 불변으로 다룬다.
- 두 벨류 객체를 비교할 때는 모든 속성이 같은지 비교한다.



## 2. 아키텍쳐 개요

> 전형적인 네 개의 영역: 표현 - 응용 - 도메인 - 인프라스트럭처

네 영역을 구성할 때는 일반적으로 계층 구조를 적용. 계층 구조를 엄격하게 적용하면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 함. 

![전형적인 계층 구조상 의존관계](https://user-images.githubusercontent.com/13076271/39467162-847e2a8e-4d67-11e8-8edb-6add012307d7.png)

예를 들어, 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라스트럭처 계층에 의존하기도 함. 하지만, 인프라스트럭처에 의존할 때는 두 가지 문제가 생김.

- 테스트의 어려움
- 기능 확장의 어려움



### DIP

이런 문제를 해소하기 위해서는 DIP<sup>dependency inversion principle</sup>를 적용해야 함.
추상화한 인터페이스를 도입함으로써 저수준 모듈이 고수준 모듈에 의존하도록 변경함.

![DIP를 적용한 구조](https://user-images.githubusercontent.com/13076271/39467265-2ecb8d9c-4d68-11e8-9e48-88dc1c78e67a.png)

주의할 점은 **저수준 모듈 관점에서 인터페이스를 도출**하면 DIP를 잘못 적용하게 됨. 고수준 모듈의 관점에서 추상화한 인터페이스를 도출하고 고수준 모듈에 위치해야 함.

![잘못된 DIP 적용 예](https://user-images.githubusercontent.com/13076271/39467340-825a6b72-4d68-11e8-9542-325db1c2072e.png)



### 도메인 영역의 주요 구성요소

- 엔티티: 고유의 식별자를 갖는 객체로 자신의 라이프사이클을 가짐. 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체.
- 벨류: 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나의 도메인 객체의 속성을 표현할 때 사용.
- 애그리거트: 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것.
- 리포지터리: 도메인 모델의 영속성 처리.
- 도메인 서비스: 특정 엔티티에 속하지 않은 도메인 로직 제공.



## 3. 애그리거트
> 애그리거트: 관련된 객체를 하나의 군으로 묶은 것.

![개별 객체 수준에서 본 모델](https://user-images.githubusercontent.com/13076271/40178432-6d01455a-5a1c-11e8-830a-721fb5ad4920.png)

- 안그래도 복잡한 도메인인데 개별 객체 수준에서 모델을 바라보면 상위 수준의 관계를 파악하기 힘듬.
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요.

![애그리거트로 묶인 모델](https://user-images.githubusercontent.com/13076271/40178473-837f6212-5a1c-11e8-963c-67af19b6255b.png)

- 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 가짐.
- 애그리거트 경계를 설정할 때 기본이 되는 것인 도메인 규칙과 요구사항.
- 대부분의 애그리거트는 한 개의 엔티티 객체만 갖는 경우가 많음. 

A가 B를 가진다. 예를 들어 상품이 리뷰를 가진다고 하면 같은 애그리거트로 묶일 것 같기도 하지만 상품과 리뷰는 함께 생성거되거나 변경 되지 않고 변경 주체도 다름. 서로 다른 애그리거트에 속함.

### 애그리거트 루트
![주문 애그리거트 예시](https://user-images.githubusercontent.com/13076271/40178488-8fad4e32-5a1c-11e8-983d-f3ad3f2a0e02.png)
애그리거트에 속한 여러 객체를 일괄성 있게 다루려면 애그리거트 전체를 관리할 주체가 필요함.

- 애그리거트 루트 엔티티의 핵심 역할은 애그리거트의 일관성 유지.
- 애그리거트는 도메인 규칙을 지키는 역할.
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 다른 객체를 직접 변경하면 안됨.
- 한 트랜잭션에서는 한 개의 애그리거트만 수정하는 것이 좋음. 부득이하게 두 애그리거트를 수정해야 한다면 응용서비스에서 처리. 도메인 이벤트를 사용하는 방법도 있음.


## 6. 응용 서비스와 표현 영역

### 응용서비스

응용서비스의 역할
- 클라이언트가 요청한 기능을 실행

- 요청을 처리하기 위해 레파지토리로부터 도메인 객체를 구하고 도메인 객체 간의 실행 흐름을 제어

- 주된 역할 중 하나는 트랜잭션 처리

- 일종의 [파사드(facade)](https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%82%AC%EB%93%9C_%ED%8C%A8%ED%84%B4) 역할

  

일반적으로 도메인 로직이 응용 서비스에 구현 되는 경우가 많은데 이 때 문제는,
- 코드의 응집성이 떨어짐
- 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아짐. 코드의 중복



또한, 표현 영역에 해당하는 `HttpServletRequest`나 `HttpSession`과 같은 웹 서비스 표현 영역에 해당하는 타입을 응용 서비스에 전달하면 안됨.



#### 응용 서비스의 크기
- 한 응용 서비스 클래스에 한 도메인의 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현

한 응용 서비스에 모든 기능을 모두 구현하면 동일한 로직을 위한 코드 중복을 제거하는 것이 쉽지만 클래스의 크기가 커짐.



#### 응용 서비스에 인터페이스를 구현해야 할까?
인터페이스가 필요한 몇가지 상황 중 하나는 구현 클래스가 여러개인 경우임. 하지만 응용 서비스의 경우 다형성이 필요한 경우가 거의 없음.
다음 글도 참고할만 함: [우아한형제들 기술 블로그 - 손권남님, 안정된 의존관계 원칙과 안정된 추상화 원칙에 대하여](http://woowabros.github.io/study/2018/03/05/sdp-sap.html)



### 표현영역

표현 영역의 역할
- 사용자가 시스템을 사용할 수 있는 (화면)흐름을 제공하고 제어
- 사용자 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
- 사용자 세션을 관리



> 읽으면서 느낀 점: 우리의 응용 서비스는 너무 많은 책임을 지고 있고 방대함. 계층 구조는 책의 예시와 비슷한 구조를 가지지만 도메인이 가져야 할 책임이 응용 서비스에 있는 경우가 많고 예외가 발생했을 때 어떤 HTTP 응답을 해야 할지도 서비스가 알고 있음. 서비스가 이 것 까지 알아야 할까?



## 7. 도메인 서비스
- 애그리거트에 넣기 애매한 도메인 개념을 구현
- 도메인 서비스는 도메인 로직을 수행하지 응용 로직을 수행하지 않음
- 상태 없이 로직만 구현함
- 응용 서비스가 애그리거트 객체에 도메인 서비스를 전달하는 책임



특정 기능이 응용서비스인지 도메인서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 게산하는지 검사해봄. 두 개 이상의 애거리거트의 도메인 로직을 수행해야 한다면 도메인 서비스로 구현.



> 읽으면서 느낀점: 도메인 서비스라는 개념을 이제까지는 따로 사용해 본 적이 없는 것 같음. 물론 도메인 개념을 나타내기 위해 별도의 클래스를 도출하는 경우는 있지만 도메인 서비스라고 의식하지는 않았음. 그리고 도메인 로직이 응용 서비스에 포함되는 경우가 많았음. 책에서 말한대로 응용 서비스와 도메인 서비스를 나눠 관리한다면 코드의 응집도가 더 높아져 관리하기 좀 더 편할 것 같음. 특히 응용서비스가 애그리거트에 도메인 서비스를 전달하고, 애그리거트 내부에서 도메인 로직을 처리하는게 인상 깊음.

## 8. 애그리거트 트랜잭션 관리
> 선점 잠금과 비선점 잠금을 선택하는 가장 중요한 기준은 충돌의 빈도와 심각도다. 충돌이 자주 발생하지 않거나 그 결과가 그리 심각하지 않다면 더 나은 동시성을 제공하고 구현하기기도 쉬운 비선점 잠금을 선택해야 한다. 그러나 충돌의 결과가 사용자에게 심각한 경우에는 선점 잠금을 사용해야 한다. - 마틴파울러 저. 엔터프라이즈 애플리케이션 아키텍처 패턴


### 선점 잠금(Pessimistic Lock)
비관적 잠금이라고도 함.

![선점 잠금의 동작 방식](https://user-images.githubusercontent.com/13076271/39954192-000daff8-55f6-11e8-8b9a-f56f297903f6.png)

- 충돌 예방에 해당 (마틴파울러 저. 엔터프라이즈 애플리케이션 아키텍처 패턴)
- 한 스레드의 트랜잭션 동안 다른 스레드는 블로킹 됨.
- 데이터 충돌 문제를 해소할 수 있음.
- 동시성이 제한 됨.
- 교착 상태 주의 필요.



### 비선점 잠금(Optimistic Lock)
![선점 잠금으로 해결할 수 없는 상황](https://user-images.githubusercontent.com/13076271/39954193-04eb102e-55f6-11e8-95e8-ddbee092c29e.png)

선점 잠금 방식으로 해결할 수 없는 경우가 있음. 이 때 비선점 잠금 방식을 고려. 낙관적 잠금이라고도 함.

![비선점 잠금을 이용한 트랜잭션 충돌 방지](https://user-images.githubusercontent.com/13076271/39954194-06998608-55f6-11e8-9c6a-e407d331952e.png)

- 충돌 감지에 해당. (마틴파울러 저. 엔터프라이즈 애플리케이션 아키텍처 패턴)
- 선점잠금과 달리 잠금을 하거나 잠금을 해서 동시 접근을 막지는 않음.
- 레코드를 읽고 버전번호를 기록함.
- 실제 레코드를 저장하는 시점에 버전을 확인.



### 오프라인 선점 잠금 (Passimistic Offline Lock)
여러 트랜잭션에 걸쳐 동시 변경을 막음. 첫번째 트랜잭션을 시작할 때 오프라인 잠금을 선점 후, 마지막 트랜잭션에서 잠금 해제. 수정 기능의 경우로 예를 들자면 폼을 보여주는 것이 첫번째 트랜잭션, 데이터를 수정하는 것이 두번째 트랜잭션임. 첫번째 트랜잭션에서 더 이상 아무 행동을 하지 않을 수 있기 때문에 잠금의 유효 시간을 가져야 함.

- 작업을 시작할 때 데이터에 대한 잠금을 획득하므로 일단 비즈니스 트랜잭션이 시작하면 동시성 제어 문제로 실패하는 경우가 거의 없음.

![오프라인 선점 잠금 - 마틴파울러 저. 엔터프라이즈 애플리케이션 아키텍처 패턴](https://user-images.githubusercontent.com/13076271/39998126-1541a80e-57c0-11e8-8700-df62c272a8d5.png)




## 9. 도메인 모델과 BOUNDED CONTEXT
모델은 특정한 **컨텍스트(문맥)하에서** 완전한 의미를 가짐.

- 한 도메인은 다시 여러 하위 도메인으로 구분 됨.
- 하위 도메인마다 같은 용어라도 의미가 다를 수 있음.
- 하위 도메인마다 논리적으로 같은 존재처럼 보이지만 지칭하는 용어가 다를 수 있음.
- 따라서 도메인을 완벽하게 표현하는 단일 모델을 만드는건 불가능함.

BOUNDED CONTEXT는 모델의 경계를 결정함.

- 도메인 모델 뿐 아니라 표현영역, 응용서비스, 인프라 영역 등을 모두 포함함.
- 이상적으로 BOUNDED CONTEXT는 한 개의 논리적 모델을 가짐.
- 용어를 기준으로 BOUNDED CONTEXT를 구분. 즉, 서로 다른 용어를 사용한다면 이 용어를 기준으로 컨텍스트를 분리할 수 있음.
- 이상적으로 하위 도메인과 BOUNDED CONTEDXT가 일대일 관계를 가지면 좋지만 기업의 팀 조직 구조에 따라 달라질 수 있음.
- 한 개의 BOUNDED CONTEXT에서 여러 하위 도메인을 포함하더라도 구분되는 패키지를 가지고 모델이 서로 뒤섞이지 않도록 노력해야 함.

BOUNDED CONTEXT 라는건 대체 대체 크기가 얼마라는건지 조금 애매한데 박성철 이사님의 글이 꽤 도움이 됐음. - [DDD 제한적 컨텍스트와 마이크로서비스의 크기](http://blog.fupfin.com/?p=161)

### BOUNDED CONTEXT 통합/관계
![Anticorruption Layer](https://user-images.githubusercontent.com/13076271/40176730-597dd0fc-5a17-11e8-9a58-f6cd8a204dc9.png)

두 BOUNDED CONTEXT가 관계를 맺을 때는 [손상 방지 계층(Anticorruption Layer)](https://docs.microsoft.com/ko-kr/azure/architecture/patterns/anti-corruption-layer)을 둬서 외부의 도메인 모델이 내 도메인 모델을 침범하지 않도록 해야 함.
이 계층에서 두 BOUNDED CONTEXT 간의 모델 변환을 처리하면 다른 BOUNDED CONTEXT의 모델에 영향 받지 않고 내 도메인 모델을 유지할 수 있음.


## 10. 이벤트

외부시스템과의 강결합(high coupling) 시에 발생하는 문제들
1. 트랜잭션 처리
  - 주문취소 -> 결제취소 트랜잭션에서 결제취소에 실패했다고 주문취소도 실패해야 하나?
2. 성능 문제 (동기 방식)
  - [Blocking-NonBlocking-Synchronous-Asynchronous](https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)
3. 서로 다른 도메인 로직이 섞임
  - 주문취소 로직에 결제취소에 관한 코드들이 드러남

이를 해결하기 위해 이벤트 라는 개념을 도입할 수 있음.

### 이벤트
> 이벤트: 과거에 벌어진 어떤 것. 암호를 변경했음, 주문을 취소했음.

이벤트는 과거 시제의 이름을 가지고 다음과 같은 정보를 담음.
- 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현. e.x.) OrderCreatedEvent
- 이벤트 발생 시간
- 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보



이벤트는 다음과 같은 용도로 쓰임.
- 트리거. e.x.) 주문을 취소하면 환불 처리가 필요한데, 이 때 주문 취소 이벤트가 환불처리를 위한 트리거가 됨.
- 서로 다른 시스템 간의 데이터 동기화



이벤트는 이벤트 핸들러가 작업을 수행하는 데 필요한 최소한의 데이터를 담아야 함. 데이터가 부족하면 핸들러가 필요한 데이터를 얻기 위해 관련 API를 호출하거나 DB에서 읽어야 하는 추가 작업이 필요함.

### 비동기 이벤트 처리
1. 회원가입을 완료한다 -> 이메일을 발송해야 한다
2. 주문을 취소한다 -> 결제를 취소한다

요구사항 중 'A하면 이어서 B하라'는 실제로는 'A하면 최대한 언제까지 B하라'인 경우가 많음. 즉, 후속 조치를 바로 할 필요 없이 일정 시간 안에만 하면 됨. 이럴 때 비동기 방식으로 이벤트를 구현할 수 있음.

- 로컬 핸들러를 비동기로 실행
- 메시지 큐 사용
  - [박용권님의 이벤트 기반 분산 시스템을 향한 여정](https://www.slideshare.net/arawnkr/ss-94475606)
- 이벤트 저장소와 이벤트 포워더 사용
- 이벤트 저장소와 이벤트 제공 API 사용

### 이벤트 적용 시 고려사항
1. 이벤트 소스 자체를 이벤트에 추가할지 여부
2. 이벤트 전송 실패를 얼마나 허용할 것인지
3. 이벤트 손실
4. 이벤트 순서
5. 이벤트 재처리
