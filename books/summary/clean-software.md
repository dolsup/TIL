# Clean Software

> 원제: Agile Software Development, Principles, Patterns, and Practices
>
> 로버트 C. 마틴. 이용원 외 2명 역. 제이펍. 2017 [[상세정보]](http://book.naver.com/bookdb/book_detail.nhn?bid=12035385)



## 7. 애자일 설계란 무엇인가

> 애자일 팀은 악취를 제거하기 위해 원칙을 적용하는데, 아무 악취도 나지 않을 때는 원칙을 적용하지 않는다. (중략) 원칙에 대한 맹종은 불필요한 복잡성이란 설계의 악취로 이어진다.



### 부패하고 있는 소프트웨어의 악취

1. 경직성: 시스템의 변경이 어려움. 변경을 하려면 시스템의 다른 부분들도 영향을 받음.
2. 취약성: 시스템의 특정 부분을 변경하면 그 부분과 개념적으로 관련 없는 부분이 망가짐.
3. 부동성: 다른 시스템에서 유용하게 쓸 수 있는 부분을 원래 시스템에서 분리하기가 어려움.
4. 점착성: 옳은 것을 하는 것이 잘못된 것을 하는 것보다 어려움. 예를 들어 변경사항을 마주했을 때, 현재 설계를 유지하는 것이 엉터리 방법보다 어렵다면 설계의 점착성이 높아진다고 할 수 있음. 
    - 점착성이라는 단어가 잘 안 와닿음. 더 어려운 방법이 점착성이 높다? '끈끈하게 착 달라붙음'?
    - 원서에서는 Viscosity 라는 단어를 사용함.
    - 점착성이라는 단어가 '[정보의 점착성이란 무엇인가?](https://blog.naver.com/ckgeem/80189670869)' 이 글에서 설명한 내용과 같은 맥락으로 사용된 것이라 생각 됨. 글에서는 단위의 정보를 받는쪽에 이용 가능한 형태로 이동시키는데 드는 비용을 점착성이라 하며 이 비용이 높을 때 점착성이 높다고 한다고 함. **비용** 의 의미를 나타내는 단어인듯.
5. 불필요한 복잡성: 현재 시점에 유용하지 않은 요소가 설계에 포함 됨. '앞으로 일어날지도 모르는 일'을 과도하게 준비함.
6. 불필요한 반복: Ctrl-C, Ctrl-V 코드의 반복.
7. 불투명성: 모듈, 코드가 읽고 이해하기 어려움. 의도를 잘 표현하지 못함.



### Copy 프로그램 예제

'Copy' 프로그램 예제에서는 소프트웨어가 개발 된 후, 요구사항의 변화를 겪으며 부패하는 예제를 보여 줌. 그 과정에서 다음과 같은 증상들이 나타났음.
- 일정을 지나치게 뻥튀기 함.
- 하지만 실제로 중간 중간 잡다한 일이 많이 끼어 들어 옴.
- 인터페이스 변경에 시스템의 많은 부분들이 영향을 받음 (하지만 이 부분은 어쩔 수 없는 부분인 것 같긴 하다. 따라서 최초에 인터페이스를 설계할 때 신중해야 하며 웹 API의 경우 버저닝 정책 등을 고려하는 듯).
- 계속되는 요구사항 변경으로 고객이 소프트웨어 설계를 망치고 있다고 탓 함.
- 변경된 기능에 대해 코드로 설명할 수 없어 주석이 추가 됨. 실제로 주석이 없다면 코드를 이해할 수 없음.

> 우리는 변하는 요구사항의 세계에 살고 있고, 우리가 만든 소프트웨어가 이런 변화 속에서 살아남을 수 있게 만드는 것이 바로 우리가 해야 하는일.

박성철님의 [슬라이드](https://www.slideshare.net/gyumee/ss-55817747)에서는 제목 그대로 소프트웨어에 유기적이라는 표현을 썼음. 소프트웨어는 생물처럼 변화에 적응하고 대응해야 함. 그럼 어떻게 해야 해?

- 시스템의 설계를 가능한 명료하고 단순하게 유지.
    - 애자일 실천방법으로 문제를 찾아냄
    - 설계 원칙을 적용해 문제를 진단
    - 적절한 방법을(패턴 등) 적용해 문제를 해결
- 이것을 많은 단위 테스트와 인수 테스트로 뒷받침.
- 절대 부패가 시작되도록 놔두지 않음. 몇 주에 한번씩 설계를 청소하지 않음. 매일, 매시간, 매분마다 함.



그런데 설계 할 때 변경을 지나치게 고려하면 복잡성이 높아진다 하고, 설계를 너무 단순하게 했다가 경직성이 높아지는데 어떡하나? 변경에 대응하기 위해 인터페이스를 도입해야 한다는 건 어떻게 알 수 있나? 객체 지향 설계의 기본적인 주의<sup>tenet</sup>을 알고 있어야 함.

## 8. 단일 책임 원칙 (Single-Responsibility Principle)
> 한 클래스는 단 한가지의 변경 이유만을 가져야 한다.

한 클래스는 하나의 책임을 가져야 하는데 SRP의 맥락에서, 책임이란 **'변경을 위한 이유'** 로 정의함.

```java
// 예제 1. 직사각형 인터페이스
interface Rectangle {
    void draw();
    double area();
}

// 예제 2. 모뎀 인터페이스
interface Modem {
    void dial(String pno);
    void hangup();
    void send(char c);
    char receive();
}
```

책에서 예로 든 위 두가지 인터페이스를 보면 현실 세계의 모델을 그대로 잘 옮겨온 것 같아 보이고 자연스럽게 인식됨.
- 예제1의 직사각형은 넓이를 계산할 수 있고 그릴 수 있음.
- 예제2의 모뎀은 연결을 관리하고 데이터 통신을 함.

하지만 현실 세계와 소프트웨어 세계는 다름. 두 예제의 책임을 서술한 문장을 보면 AND('있고', '하고') 가 포함. 이는 두가지 책임을 지고 있다고 할 수 있고 클래스를 변경해야 하는 이유가 두 가지가 됨.

![SRP는 Actor에 관한 것](https://user-images.githubusercontent.com/13076271/41201081-50f849b6-6cec-11e8-8094-0d638982091e.png)

> 그림 출처: [백명석님 Youtube - 클린 코더스 강의 13. SRP(Single Responsibility Principle)](https://youtu.be/AdANHDp5dTM)

백명석님의 강의를 보면 '누가 해당 메소드의 변경을 유발하는 사용자인가'에 따라 책임을 나눌 수 있다고 함. 해당 메서드를 누가 호출하는가? 

- 메서드를 호출하는 각각의 User가 있음.
- User는 각각의 User로 전부 구분하는 것이 아니라 그들이 수행하는 Role에 따라 나뉨.
- User가 특정 Role을 수행할 때 Actor라고 부름.
- 책임은 개인(User)가 아니라 Actor와 연결.

Actor들을 Serve하는 책임을 식별하는 일이 필요.

![](https://user-images.githubusercontent.com/13076271/41202775-b520904e-6d08-11e8-9f8f-5ef25cbf46a2.png)

> 그림 출처: [백명석님 Youtube - 클린 코더스 강의 13. SRP(Single Responsibility Principle)](https://youtu.be/AdANHDp5dTM)

그런데 이렇게 Actor를 찾아내고 다이어그램을 그리고 코드로 구현하는 일이 폭포수<sup>waterfall</sup>모델로 차례 차례 진행되기는 굉장히 어려움. 테스트를 바탕으로 동작하는 모델을 만든 후 그 과정에서 책임을 식별하고 리팩터링 과정을 거침. 이쁜 다이어그램이 그려질 수 있는 건 모든 구현이 완료 된 후임.



SRP를 어렵게 하는 또 한 가지는 두 책임이 항상 분리 되어야만 하는 것은 아님. 앞으로 애플리케이션이 어떻게 바뀌느냐에 달려 있음. 두 가지 책임에 대해 각각 변경이 유발될 일이 없다면 분리가 오히려 불필요한 복잡성을 유발함. 그러나 많은 경우 변경 되는 것 같음.

` // TODO: 실제 경험 사례 내용을 추가하면 좋을 것 같은데 뭐가 있을까..`
