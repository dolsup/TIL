# GOF의 디자인 패턴

> Gang of four 저. 김정아 역. 프로텍미디어. 2015 [링크](https://book.naver.com/bookdb/book_detail.nhn?bid=8942623)

# 1. 서론
> 각 디자인 패턴은 기존 환경 내에서 반복적으로 일어나는 문제들을 설명한 후, 그 문제들에 대한 해법의 핵심을 설명해 줍니다. 똑같은 방법으로 두 번 일하지 않고 이 해법을 100만 번 이상 재사용할 수 있도록 말이죠. - 건축가이자 패턴의 아버지, 크리스토퍼 알렉산더



## 디자인 패턴

전문가들은 초보자들처럼 모든 문제를 처음 기초 단계에서부터 해결하려고 하지 않음. 대신, 전에 사용했던 해결책을 다시 사용해봄.

### 패턴의 네 가지 요소
- 패턴 이름: 한 두 단어로 설계 문제와 해법을 서술.
- 문제: 해결할 문제와 그 배경.
- 해법: 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임, 그리고 협력 관계 서술. 단, 디자인패턴도 단순히 템플릿<sup>template</sup>일 뿐. 구체적인 구현은 경우에 따라 조금씩 다를 수 있음.
- 결과: 패턴을 적용해서 얻는 결과와 장단점.

### 패턴을 이용하여 문제를 해결하는 방법
#### 1. 적당한 객체 찾기
- 객체지향 설계의 가장 어려운 부분은 시스템을 구상할 객체의 분할을 결정하는 것.
- 고려해야 할 요인에는 캡슐화, 객체의 크기, 종속성, 유연성, 성능, 진화, 재사용성 등.
- 이 모두를 어떻게 고려하는가에 따라 서로 다른 방법으로 분할이 가능.
- 따라서 어느 방법이 가장 좋은 방법이라고 말할 수 없음.
- 실세계 != 객체지향 설계.
- 실세계를 그대로 반영하는 모델링은 현재를 반영할 수 있지만 미래의 실세계는 반영할 수 없음.
- 객체지향 설계 단계 동안 만들어야 하는 새로운 추상화는 설계의 유연성을 증진하기 위한 노력 중 하나.

#### 2. 객체의 크기 결정
- 객체의 크기나 개수는 딱 정해져 있지 않음.

#### 3. 객체 인터페이스의 명세
- 연산의 이름, 매개변수로 받아들이는 객체, 연산의 반환 값. 이를 연산의 시그니처<sup>signature</sup>라고 함. (자바는 반환 값이 시그니쳐에 포함되지 않음.)
- 인터페이스<sup>interface</sup>는 객체가 정의하는 모든 시그니처를 일컫는 말. 객체가 처리할 수 있는 연산의 집합.
- 타입은 특정 인터페이스를 나타낼 때 사용하는 이름. 특정 타입을 갖는 다는 것은 해당 인터페이스에 정의한 연산을 모두 처리할 수 있음을 뜻함.
- 객체는 여러 타입을 가질 수 있고, 서로 다른 객체가 하나의 타입을 공유할 수 있음.
- 객체는 인터페이스로 자신을 드러냄. 외부에서는 객체의 구현에 대해는 알지 못함.
- 요청을 받는 객체는 같은 타입이라면 다른 객체로 대체될 수 있는 다형성<sup>polymorphism</sup>을 가짐.

#### 4. 객체 구현 명세
- 객체의 구현은 클래스<sup>class</sup>에 정의 함.
- 클래스는 객체의 내부 데이터와 표현 방법을 명세하고, 그 객체가 수행할 연산을 정의.
- 객체는 클래스를 인스턴스로 만듦으로써 생성 됨.
- 서브클래스가 부모클래스를 상속하면, 부모 클래스가 갖는 모든 데이터와 연산을 서브클래스가 공유함.

##### 클래스 상속 대 인터페이스 상속
- 클래스는 객체의 내부 상태와 그 객체의 연산에 대한 구현 방법을 정의.
- 객체의 타입은 그 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의.
- 클래스 상속은 코드와 내부 표현 구조를 공유하는 메커니즘.
- 인터페이스 상속(서브타이핑)은 어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하는 메커니즘.

##### 상속 대 합성
- 클래스 상속은 화이트박스 재사용. 부모클래스의 내부가 서브클래스에 공개 됨.
- 객체 합성은 블랙박스 재사용. 객체 내부는 공개되지 않고 인터페이스를 통해서만 재사용 됨.
- 클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수 있고, 일부만 재정의할 수 도 있음.
- 클래스 상속의 단점은 (1)런타임에 상속받은 부모 클래스의 구현을 변경할 수 없음 (2)서브클래스는 부모클래스에 종속적임.
- 객체 합성은 객체들의 캡슐화를 유지할 수 있고, 동일한 타입을 갖는다면 런타임에 다른 객체로 대체가 가능함. 구현 사이의 종속성이 줄어듬.

#### 5. 런타임 및 컴파일 타임의 구조를 관계짓기
- TODO: 무슨 말인지 잘 이해 못함.

#### 6. 변화에 대비한 설계
디자인 패턴은 어떤 구체적인 원인으로 앞으로 시스템을 변경해야 한다는 것을 미리 보여줌.
- 특정 클래스에서 객체 생성: 클래스 내에서 객체를 직접 생성하면 특정 구현에 종속 됨.
- 특정 연산에 대한 의존성: 요청의 처리 방법을 직접 코딩하는 방식을 피하면, 컴파일 시점과 런타임 모두를 만족하며 처리 방법을 쉽게 변경할 수 있음.
- 하드웨어와 스포트웨어 플랫폼에 대한 의존성
- 객체의 표현이나 구현에 대한 의존성: 사용자가 객체의 표현, 저장, 구현 등 모든 방법을 알고 있다면 객체를 변경할 때 사용자도 함께 변경해야 함.
- 알고리즘 의존성: 알고리즘에 종속 된 객체라면 알고리즘이 변할 때마다 객체도 변경해야함.
- 높은 결합도: 높은 결합도를 갖는 클래스는 독립적으로 재사용하기 어려움. 클래스 하나를 수정하기 위해 전체를 이해하고 변경해야 함.
- 서브클래싱을 통한 기능 확장: 서브클래스를 정의하려면 최상위 클래스부터 자신의 직속 부모 클래스까지 모든 것을 이해해야 함. 또한 새로운 서브클래스가 생길 때마다 매번 반드시 해야 하는 초기화, 소멸 등에 대한 구현 오버헤드를 늘 지게 됨.



### 패턴을 고르는 방법

1. 패턴이 어떻게 문제를 해결하는지 파악 함.

2. 패턴의 의도를 읽음.

3. 패턴들 간의 관련성을 파악.

4. 비슷한 목적의 패턴들을 모아서 공부.

5. 재설계의 원인을 파악.

6. 설계에서 가변성을 가져야 하는 부분이 무엇인지 파악.