# 테스트 주도 개발로 배우는 객체 지향 설계와 실천
> 스티브 프리먼 외, 이대엽 역, 인사이트 출판, 2013 [[링크](http://www.yes24.com/24/Goods/9008455?Acode=101)]

<!-- TOC -->

- [테스트 주도 개발로 배우는 객체 지향 설계와 실천](#테스트-주도-개발로-배우는-객체-지향-설계와-실천)
    - [1장 서론](#1장-서론)
        - [변화를 돕는 실천법](#변화를-돕는-실천법)
        - [테스트주도개발의 핵심 주기](#테스트주도개발의-핵심-주기)
        - [테스트 수준](#테스트-수준)
    - [2장 객체를 활용한 테스트 주도 개발](#2장-객체를-활용한-테스트-주도-개발)
        - [객체망](#객체망)
        - [메세지를 따르라](#메세지를-따르라)
        - [묻지 말고 말하라](#묻지-말고-말하라)
        - [그래도 가끔 물어라](#그래도-가끔-물어라)

<!-- /TOC -->

## 1장 서론
### 변화를 돕는 실천법
시스템 규모를 믿을 수 있는 방식으로 키우고, 늘 일어나는 예상치 못한 변화에 대처하기 위한 기술적 토대

1. 회귀 오류를 잡아 줄 꾸준한 테스트
2. 코드 베이스를 가능한 단순하게 유지

이해와 수정이 쉬운 단순한 코드를 위해 설계를 개선하고 단순화하고, 중복 제거 등 꾸준히 리팩터링을 하기 위해서는 테스트 코드가 필요 함.

하지만 테스트 작성을 개발자들은 따분해 함. TDD는 작업을 완료한 후 작업 결과를 검증하려고 테스트를 작성하는 것이 아니라 **설계 활동으로 전환**시킴.



### 테스트주도개발의 핵심 주기
> 테스트 작성  > 테스트가 동작하게 만들 코드 작성 > 코드를 가급적 테스트한 기능의 단순한 구현으로 리팩터링

TDD를 통해 시스템 구현(“시스템이 동작하는가?”)과 설계(“시스템이 잘 구조화돼 있는가?”)의 품질에 관한 피드백을 얻음.


### 테스트 수준
- 인수 테스트: 전체 시스템이 동작하는가?
- 통합 테스트: 변경할 수 없는 코드를 대상으로 코드가 동작하는가?
- 단위 테스트: 객체가 제대로 동작하는가? 객체를 이용하기가 편리한가?

단위 테스트만 있는 프로젝트는 TDD 프로세스가 주는 아주 중요한 혜택을 놓치고 있는 셈.

![TDD 내에서의 안팎 피드백 고리](https://user-images.githubusercontent.com/13076271/36789676-b6d0e48a-1cd5-11e8-8e44-46572ead4dbf.png)

어떤 기능을 구현할 때 인수테스트를 작성하는 것으로 시작한다. 여기서 인수테스트란 만들고자 하는 기능을 시험하는 테스트를 말함. 인수테스트 하에서는 단위 테스트 수준의 테스트, 구현, 리팩터링 주기를 따라 기능을 개발. 전체 주기는 위 그림과 같음.

> 여기서 기능의 범주는? 단순히 메서드가 동작하는, 객체 수준에서 메세지를 주고 받는 것이 아니라 외부에서 유입되는 시스템(end-to-end)과의 상호작용

## 2장 객체를 활용한 테스트 주도 개발
### 객체망
![객체망](https://user-images.githubusercontent.com/13076271/36846858-ac9fd71c-1d9f-11e8-8ae5-b84f51a15dc4.png)

객체 지향 설계는 객체 자체보다 객체 간의 의사소통에 더 집중.
- 객체 지향 시스템은 협업하는 객체의 망으로 구성
- 시스템의 행위는 객체의 조합을 통해 나타나는 특성
- 객체 구성을 관리할 목적으로 작성하는 코드를 객체망의 행위에 대한 선언적 정의라 함

시스템을 이런식으로 구축하면 방법(how)이 아니라 목적(what)에 집중할 수 시스템의 행위를 변경하기 쉬움.

### 메세지를 따르라
다른 객체와 쉽게 관계를 맺을 수 있게 객체를 설계하기만 한다면 고수준의 선언적 접근법이 주는 혜택을 누릴 수 있음.
이는 객체가 일반적인 의사소통 패턴을 따르고 객체 간의 의존성이 명시적임을 의미함.

- 도메인 모델은 의사소통 패턴에 속함
- 의사소통 패턴은 객체 간에 있을 법한 관계에 의미를 부여
- 의사소통 구조는 객체라는 것을 처음 접할 때 배운 정적인 분류에서 개념적으로 굉장히 발전한 단계

### 묻지 말고 말하라
- 객체는 그것이 내부적으로 보유하고 있거나 메시지를 통해 확보한 정보만으로 의사 결정을 내려야 함.
- 객체는 다른 객체를 탐색해 뭔가를 일어나게 해서는 안됨.

이 스타일을 일관되게 따르면 코드가 좀 더 유연해짐. 객체를 손쉽게 교체할 수 있기 때문. 반면, 이 스타일을 따르지 않으면 '열차 전복' 코드가 만들어짐.

```java
(EditSaveCustomizer) master.getModelisable()
    .getDockablePanel()
    .getCustomizer()
    .getSaveItem.setEnabled(Boolean.FALSE.booleanValue());

// 위 코드는 다음과 같은 의미다
master.allowSavingOfCusomisations();
```
묻지 말고 답하라 (디미터의 법칙)를 따르면 객체 간의 상호 작용을 명시적으로 만들고 거기 이름을 부여 하게 됨. `master.allowSavingOfCusomisations()`는 코드의 목적을 훨씬 명확히 드러낸다.

### 그래도 가끔 물어라
값과 컬렉션으로부터 정보를 가져와 필터링하거나 팩터리를 이용해 새 객체를 생성할 때 가끔 '묻게 됨'.

```java
if (carriage.getSeates().getPercentReserved() < percentReservedBarrier) {
    // ...
}
```

위 코드처럼 Carriage의 내부 구조를 노출하고 스스로 답을 가늠하는 대신 아래와 같이 작성할 수 있음.

```java
if (carriage.hasSeatsAvailabledWithin(percentReservedBarrier)) {
    // ...
}
```

진정 답하고자 하는 질문을 던져 행위에 이해하기 쉬운 이름이 생김.
